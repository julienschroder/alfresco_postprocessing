import numpy as np
def get_veg_metric( veg_dd, domain_name, veg_name, aggregator=np.mean, axis=1 ):
	'''
	veg_dd = [dict] dictionary of dataframes of veg_counts metrics from alfresco_postprocessing
		* typically generated by `veg_dd = plotobj.get_metric_dataframes('veg_counts')`
	domain_name = [str] domain name
	veg_name = [str] vegetation string name -- must be EXACT... 
	aggregator = [function] function that will take an array as its only argument and return a single
		metric derived from this function.  i.e. np.mean, np.sum, np.min, etc... 
	axis = [int] 0  =aggregate across rows in the column; 1 = aggregate across columns in rows

	returns:
	pandas.Series object with the result either across years or replicates depending on axis=0 or axis=1
	'''
	return veg_dd[ domain_name ][ veg_name ].apply( aggregator, axis=axis )

def generate( ax, meanline, lower, upper, label, linecolor, rangecolor, alpha, line_zorder, *args, **kwargs ):
	'''
	overlay lines and ranges...

	ax = mpl axes object to use for plotting lines and ranges
	meanline = pandas.Series with index of years and summarized line values (mean)
	lower = pandas.Series with index of years and summarized line values (min) for fill_between
	upper = pandas.Series with index of years and summarized line values (max) for fill_between
	linecolor = matplotlib compatible color for the line object
	rangecolor = matplotlib compatible color for the fill_between object
	alpha = transparency level
	'''
	# plot line
	years = meanline.index.astype( int )
	ax.plot( np.array(years), np.array(meanline), lw=0.8, label=label, color=linecolor, alpha=1, zorder=line_zorder )
	# fill between axes
	ax.fill_between( np.array(years), np.array(lower), np.array(upper), facecolor=rangecolor, alpha=alpha, linewidth=0.0, label='range' )
	return ax

def get_veg_ratios( veg_dd, domain_name='AOI_SERDP', group1=['White Spruce', 'Black Spruce'], group2=['Deciduous'] ):
	'''
	calculate ratios from lists of veg types.
	'''
	agg1 = sum([ veg_dd[ domain_name ][ i ] for i in group1 ])
	agg2 = sum([ veg_dd[ domain_name ][ i ] for i in group2 ])
	return agg1 / agg2


if __name__	 == '__main__':
	import matplotlib, os
	matplotlib.use( 'Agg' )
	import matplotlib.pyplot as plt
	import matplotlib.patches as mpatches
	import numpy as np
	import pandas as pd
	from alfresco_postprocessing import plot
	from matplotlib import rcParams
	from functools import partial

	# set some rcparams
	rcParams[ 'xtick.direction' ] = 'out'
	rcParams[ 'ytick.direction' ] = 'out'

	# read in the data
	model = 'GISS-E2-R'
	scenario = 'rcp85'
	json = '/workspace/Shared/Users/jschroder/ALFRESCO_SERDP/Data/ALFRESCO_SERDP_highcalib/post_processing_outputs/GISS-E2-R_rcp85.json'
	json_alt = '/workspace/Shared/Users/jschroder/ALFRESCO_SERDP/Data/ALFRESCO_SERDP_highcalib/post_processing_outputs/GISS-E2-R_rcp85_AltFMO.json'
	json_no = '/workspace/Shared/Users/jschroder/ALFRESCO_SERDP/Data/ALFRESCO_SERDP_highcalib/post_processing_outputs/GISS-E2-R_rcp85_NoFMO.json'

	# mean Black Spruce full domain
	domain_name = 'AOI_SERDP'
	veg_name = 'Black Spruce'
	aggregator = np.mean
	axis = 1

	# setup 
	figsize = ( 14, 9 )
	fig, ax = plt.subplots( 1 )

	# setup spines
	ax.spines[ "top" ].set_visible( False ) 
	ax.spines[ "bottom" ].set_visible( True )
	ax.spines[ "right" ].set_visible( False )
	ax.spines[ "left" ].set_visible( True )

	ax.get_xaxis().tick_bottom()
	ax.get_yaxis().tick_left()
	# args_list = [(json_no, 'darkblue', 'lightblue', 1),(json_alt, 'darkred', 'crimson', 2), (json, 'black','lightgrey', 3)]
	args_list = [(json_no, 'darkblue', 'grey', 1),(json_alt, 'darkred', 'grey', 2), (json, 'black','grey', 3)]
	# loop through the files:
	for j, k, l, m in args_list:
		
		n = len( args_list ) # maybe use the number of individual groups to determine the ordering of the ranges?

		# open em up
		plotobj = plot.Plot( j, model, scenario )

		# data getter:
		veg_dd = plotobj.get_metric_dataframes( 'veg_counts' )

		# # get the C:D ratios
		# ratios = get_veg_ratios( veg_dd, domain_name='AOI_SERDP', group1=['White Spruce', 'Black Spruce'], group2=['Deciduous'] )
		# ratios_mean = ratios.mean( axis=1 )
		# ratios_min = ratios.min( axis=1 )
		# ratios_max = ratios.max( axis=1 )

		# # FOR TESTING:
		# modeled_mean = ratios_mean
		# modeled_min = ratios_min
		# modeled_max = ratios_max

		# # get the metrics -- veg counts
		modeled_mean = get_veg_metric( veg_dd, domain_name, veg_name, aggregator=np.mean, axis=1 )
		# modeled_min = get_veg_metric( veg_dd, domain_name, veg_name, aggregator=np.min, axis=1 )
		# modeled_max = get_veg_metric( veg_dd, domain_name, veg_name, aggregator=np.max, axis=1 )
		
		# # THE INTERQUARTILE RANGE 5/95 PERCENTILE
		f = partial( np.percentile, q=5 ) # 5th percentile
		modeled_min = get_veg_metric( veg_dd, domain_name, veg_name, aggregator=f, axis=1 )
		f = partial( np.percentile, q=95 ) # 95 percentile
		modeled_max = get_veg_metric( veg_dd, domain_name, veg_name, aggregator=f, axis=1 )
		
		# get labels to pass through from the json filenames << - this is hacky and will break
		label = os.path.basename( j ).split( '.' )[0].split( '_' )[-1]
		
		# label renamer: special case due to numerous id changes
		switch = { u'NoFMO':'No FMPO', u'AltFMO':'FMPO' }
		if label in switch.keys():
			label = switch[ label ]

		# plot it
		generate( ax, modeled_mean, modeled_min, modeled_max, label=label, linecolor=k, rangecolor=l, alpha=0.5, line_zorder=m )

	# legend
	# legend = ax.legend( loc='best' )
	handles, labels = ax.get_legend_handles_labels()
	handles = handles[:3]
	labels = labels[:3]
	# ax.legend( handles, labels, bbox_to_anchor=(1.05, 1), loc=2, borderaxespad=0. )
	ax.legend( handles, labels, loc='upper center', ncol=3, borderaxespad=0., fancybox=True, bbox_to_anchor=(0.5, 1.05) ) # bbox_to_anchor=(0., 1, 1., 0 ), mode="expand",
	# ax.legend( handles, labels, bbox_to_anchor=(0., 1.02, 1., .102), loc=3, ncol=3, mode="expand", borderaxespad=0.)
	
	# labels
	plt.xlabel( 'Year' )
	plt.ylabel( '$\mathregular{km^2}$' )

	# title
	years = plotobj.years.astype( np.int )
	plot_title = 'Average Area of %s %d-%d \n ALFRESCO, %s, RCP 8.5' % ( veg_name, years.min(), years.max(), model )
	# plot_title = 'Conifer Deciduous Ratios %d-%d \n ALFRESCO, %s, RCP 8.5' % ( years.min(), years.max(), model )
	figsize = ( 16, 9 )
	plt.title( plot_title , y=1.08 )

	# limits
	plt.xlim( years.min(), years.max() )
	
	# ticks
	plt.xticks( np.append( years[::10], 2100 ), rotation=45 ) # make this dynamic!

	# y-axis acreage 
	y1, y2 = ax.get_ylim()
	x1, x2 = ax.get_xlim()
	
	# make new axis
	ax2 = ax.twinx()

	# set it to the acreage in the same limit bounds
	acre_conv = 247.105
	ax2.set_ylim( y1*acre_conv, y2*acre_conv )
	# ax2.set_yticks( [ i*acre_conv for i in ax.get_yticks() ] )
	ax2.set_ylabel( 'acres' )
	ax2.set_xlim( x1, x2 )

	# ax2 spines
	ax2.spines[ "top" ].set_visible( False ) 
	ax2.spines[ "left" ].set_visible( False )

	plt.minorticks_on()
	ax.minorticks_on()

	# save it/close
	plt.savefig( '/workspace/Shared/Users/malindgren/AMY_SERDP/test_newplot_iqr_grey_acres.png', figsize=figsize, dpi=600, bbox_inches='tight', pad_inches=0.2 )
	# plt.savefig( '/workspace/Shared/Users/malindgren/AMY_SERDP/test_newplot_mm.png', figsize=figsize )
	plt.close( 'all' )
